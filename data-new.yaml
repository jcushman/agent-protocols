title: The Agent Protocol Tech Tree
subtitle: How open standards for AI agents emerged, layer by layer

actor_icons:
  app: images/actor-app.png
  model: images/actor-model.png
  server: images/actor-server.png
  agent: images/actor-agent.png
  repo: images/actor-repo.png
  website: images/actor-website.png
  registry: images/actor-registry.png
  merchant: images/actor-merchant.png
  skill: images/actor-skill.png

# Background columns (visual eras). Nodes are free-positioned via layout.x/layout.y.
eras:
  - id: foundations
    x0: -1.4
    x1: -0.1
    label: Model Foundations
  - id: inference
    x0: 0.0
    x1: 1.0
    label: Inference
  - id: tooluse
    x0: 1.0
    x1: 2.2
    label: Tool Use
  - id: ecosystem
    x0: 2.2
    x1: 4.4
    label: Ecosystem
  - id: domains
    x0: 4.4
    x1: 5.8
    label: Domains
  - id: frontier
    x0: 5.8
    x1: 7.0
    label: Frontier

# Clusters are decorative group boxes. Members are technology ids.
clusters:
  - id: c-foundations
    label: Pre-API quasi-standards
    members: [tokenizers, weight-formats, embeddings, chat-templates]
    style: { kind: "cluster", tone: "muted" }

  - id: c-instruction
    label: Instruction Surfaces
    members: [agents-md, llms-txt, agent-skills]
    style: { kind: "cluster", tone: "default" }

  - id: c-agent-interop
    label: Agent Interop
    members: [mcp, mcp-apps, a2a]
    style: { kind: "cluster", tone: "default" }

  - id: c-domain
    label: Domain Protocols
    members: [ucp, agent-identity]
    style: { kind: "cluster", tone: "default" }

  - id: c-frontier
    label: Likely Next Protocols
    members: [agent-audit, intent-mandates, agent-registries, skill-security]
    style: { kind: "cluster", tone: "muted" }

# Node types and unlock states are rendered by the viewer.
# - unlock.state: locked | unlocked (default: unlocked)
# - unlock.class: foundational | frontier
# - unlock.icon: centered overlay icon for locked nodes
technologies:
  # â”€â”€ Foundations (locked by default; "stone-age" unlocks) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: tokenizers
    title: Tokenizers as Interop Artifacts
    icon: images/icon-tokenizers.png
    icon_alt: "tok"
    layout: { x: -1.05, y: 1.35 }
    unlock: { state: locked, class: foundational, icon: images/unlock-stone.png }
    tree:
      depends_on: []
    detail:
      links:
        - { label: "Standard", url: "https://github.com/huggingface/tokenizers" }
      what_it_solves: >-
        A portable textâ†”token-id boundary so model weights and runtimes agree on
        exactly how to encode inputs and decode outputs.
      how_its_standardizing: >-
        Converged through de facto artifacts (vocab/merges, SentencePiece models,
        tokenizer.json) adopted by model publishers and runtimes rather than a
        formal standards body.
      virtuous_cycle:
        - "Model publishers ship a tokenizer artifact so downstream users can run the model."
        - "Runtime/tooling authors implement the common artifacts to support many models."
        - "New models choose widely supported tokenizer formats to maximize portability."

  - id: weight-formats
    title: Weight Container Formats
    icon: images/icon-weights.png
    icon_alt: "w"
    layout: { x: -1.05, y: 2.05 }
    unlock: { state: locked, class: foundational, icon: images/unlock-stone.png }
    tree:
      depends_on: []
    detail:
      links:
        - { label: "Standard", url: "https://github.com/huggingface/safetensors" }
      what_it_solves: >-
        A safe, fast way to distribute model tensors across frameworks and runtimes.
      how_its_standardizing: >-
        De facto convergence on formats like safetensors (safety/perf) and GGUF
        (local inference ecosystem), driven by tool support and publishing norms.
      virtuous_cycle:
        - "Publishers pick formats that load everywhere with minimal risk."
        - "Runtimes support formats that unlock the largest model catalog."
        - "Converters/quantizers flourish once a stable on-disk format is common."

  - id: embeddings
    title: Embeddings + Vector Search Conventions
    icon: images/icon-embeddings.png
    icon_alt: "vec"
    layout: { x: -1.05, y: 2.75 }
    unlock: { state: locked, class: foundational, icon: images/unlock-stone.png }
    tree:
      depends_on: []
    detail:
      links:
        - { label: "Standard", url: "https://opensearch.org/docs/latest/search-plugins/knn/" }
      what_it_solves: >-
        A universal â€œvector + metadataâ€ interface enabling retrieval, semantic search,
        and RAG pipelines regardless of the embedding model or vector store.
      how_its_standardizing: >-
        Converged by API similarity across vector DBs and common client expectations
        (float[] vectors, metadata filters, upsert/query) rather than a single spec.
      virtuous_cycle:
        - "Apps rely on a stable vector interface; swapping stores/models becomes easy."
        - "DBs adopt common ops (upsert/query/filter) to capture the same client ecosystem."
        - "Model providers target vector-friendly shapes to plug into common retrieval stacks."

  - id: chat-templates
    title: Chat Templates + Role Schemas
    icon: images/icon-chat-templates.png
    icon_alt: "msg"
    layout: { x: -1.05, y: 3.45 }
    unlock: { state: locked, class: foundational, icon: images/unlock-stone.png }
    tree:
      depends_on: []
    detail:
      links:
        - { label: "Standard", url: "https://huggingface.co/docs/transformers/main/chat_templating" }
      what_it_solves: >-
        A portable way to represent multi-turn conversations and serialize them into
        model-specific token sequences correctly.
      how_its_standardizing: >-
        Dataset schemas converged on role/content turns; chat template metadata
        (e.g., in tokenizers/configs) enabled generic chat UIs to support many models.
      virtuous_cycle:
        - "Apps can target a consistent message schema across models."
        - "Model publishers ship templates so generic clients can format prompts correctly."
        - "Evaluation/training pipelines reuse the same role/content structure at scale."

  # â”€â”€ Inference (core) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: inference-api
    title: Inference API
    icon: images/icon-inference-api.png
    icon_alt: ">_"
    tagline: A stable way to talk to any model
    layout: { x: 0.45, y: 2.10 }
    tree:
      depends_on: []
    detail:
      links:
        - { label: "Launch", url: "https://openai.com/index/introducing-chatgpt-and-whisper-apis/" }
        - { label: "Standard", url: "https://platform.openai.com/docs/api-reference/chat" }
      what_it_solves: >-
        A consistent way to send prompts to language models and receive responses
        without rewriting code for every provider. A chat-style shape made LLMs
        a reliable, swappable component.
      how_its_standardizing: >-
        Initially launched by OpenAIâ€™s chat-completions shape; widespread compatibility
        emerged because providers and open-source servers implemented similar request/response
        structures to reduce ecosystem friction.
      virtuous_cycle:
        - "App makers target one interface and can switch providers with minimal changes."
        - "Model hosts gain adoption by being drop-in compatible with existing clients."
        - "Tooling (SDKs, gateways, proxies) compounds around the common shape."
    animation:
      actors:
        - { id: app, label: "Your App", type: app }
        - { id: provider, label: "Model Provider", type: server }
      scenes:
        - title: App calls a model
          actors_visible: [app, provider]
          messages:
            - from: app
              to: provider
              label: Chat request
              json_preview: '{"model":"...","messages":[{"role":"user","content":"Hello"}]}'
            - from: provider
              to: app
              label: Chat response
              json_preview: '{"choices":[{"message":{"role":"assistant","content":"Hi!"}}]}'

  # â”€â”€ Tool Use (core) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: tool-calling
    title: Tool Calling
    icon: images/icon-tool-calling.png
    icon_alt: "f(x)"
    tagline: Models that can take action
    layout: { x: 1.35, y: 2.10 }
    tree:
      depends_on: [inference-api]
    detail:
      links:
        - { label: "Launch", url: "https://openai.com/index/function-calling-and-other-api-updates/" }
        - { label: "Standard", url: "https://platform.openai.com/docs/guides/function-calling" }
      what_it_solves: >-
        A structured â€œcall this function with these argumentsâ€ channel so models can
        trigger real actions (search, files, APIs) and then incorporate results.
      how_its_standardizing: >-
        Launched as function-calling and generalized into tool-calling patterns across
        providers. Standardization is de facto: common JSON-schema-like signatures and
        tool-call/result message roles.
      virtuous_cycle:
        - "App makers expose capabilities once and reuse them across many models."
        - "Model makers support tool calling to be useful in real workflows, not just chat."
        - "Tool ecosystems emerge because definitions are machine-readable and reusable."
    animation:
      actors:
        - { id: app, label: "Your App", type: app }
        - { id: model, label: "LLM", type: model }
      scenes:
        - title: Model requests a tool
          actors_visible: [app, model]
          messages:
            - from: app
              to: model
              label: Prompt + tools
              json_preview: '{"messages":[...],"tools":[{"type":"function","function":{"name":"get_weather"}}]}'
            - from: model
              to: app
              label: tool_call
              json_preview: '{"tool_calls":[{"function":{"name":"get_weather","arguments":"{\"location\":\"Boston\"}"}}]}'

  # New: the â€œstandard tools surfacesâ€ box (browser/cli/code)
  - id: standard-tool-surfaces
    title: Standard Tool Surfaces
    icon: images/icon-tool-surfaces.png
    icon_alt: "ðŸ§°"
    tagline: Where agents reliably act
    layout: { x: 2.15, y: 2.10 }
    tree:
      depends_on: [tool-calling]
    detail:
      links:
        - { label: "Standard", url: "https://platform.openai.com/docs/guides/tools" }
      what_it_solves: >-
        A small set of â€œcanonicalâ€ action surfaces that tool ecosystems and finetunes
        converge on: Browser, Command Line, and Code execution/editing.
      how_its_standardizing: >-
        Not a single spec; a convergence in agent platforms toward stable tool categories
        and semantics (navigate/click/type; run commands; apply patches/tests) because those
        cover most real-world tasks.
      virtuous_cycle:
        - "Tool makers target the common surfaces to reach many agent hosts."
        - "Agent hosts standardize these surfaces to maximize reliability and safety controls."
        - "Model training/evaluation can focus on a stable set of action types."

  # â”€â”€ Ecosystem (interop protocols + instruction surfaces, spread out) â”€â”€
  - id: mcp
    title: MCP
    icon: images/icon-mcp.png
    icon_alt: "<>"
    tagline: One protocol for every tool
    layout: { x: 2.85, y: 0.95 }
    tree:
      depends_on: [tool-calling]
    detail:
      links:
        - { label: "Launch", url: "https://www.anthropic.com/news/model-context-protocol" }
        - { label: "Standard", url: "https://modelcontextprotocol.io/specification/" }
      what_it_solves: >-
        Replaces NÃ—M bespoke integrations between apps and tool providers with one
        client/server protocol: discover tools, call tools, exchange resources.
      how_its_standardizing: >-
        Launched by Anthropic; rapidly adopted by IDEs and agent platforms. Ongoing
        stewardship is community-driven through an expanding ecosystem of clients/servers.
      virtuous_cycle:
        - "Tool providers implement one server and reach many MCP clients."
        - "Clients add one protocol and gain access to a growing tool catalog."
        - "Shared conventions reduce integration cost and accelerate new tools."
    animation:
      actors:
        - { id: client, label: "MCP Client", type: app }
        - { id: server, label: "MCP Server", type: server }
      scenes:
        - title: tools/list then tools/call
          actors_visible: [client, server]
          messages:
            - from: client
              to: server
              label: tools/list
              json_preview: '{"jsonrpc":"2.0","id":1,"method":"tools/list"}'
            - from: client
              to: server
              label: tools/call
              json_preview: '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"read_file","arguments":{"path":"README.md"}}}'

  - id: mcp-apps
    title: MCP Apps
    icon: images/icon-mcp-apps.png
    icon_alt: "UI"
    tagline: Interactive UIs for tool servers
    layout: { x: 3.55, y: 0.95 }
    tree:
      depends_on: [mcp]
    detail:
      links:
        - { label: "Standard", url: "https://modelcontextprotocol.io/docs/extensions/apps" }
      what_it_solves: >-
        Lets tool providers ship sandboxed UI surfaces (previews, editors, dashboards)
        integrated into agent hostsâ€”without giving raw OS control to the model.
      how_its_standardizing: >-
        Evolved as an MCP extension. Standardization is driven by host support (clients)
        and shared UI embedding + messaging conventions (sandboxed iframe + notifications).
      virtuous_cycle:
        - "Tool providers can deliver better UX without per-host bespoke UI work."
        - "Hosts gain safer, richer interactions than pure JSON tool results."
        - "A common UI embedding model encourages more reusable tool apps."

  - id: a2a
    title: A2A
    icon: images/icon-a2a.png
    icon_alt: "â†”"
    tagline: Agents working across frameworks
    layout: { x: 3.15, y: 3.95 }
    tree:
      depends_on: [tool-calling]
    detail:
      links:
        - { label: "Launch", url: "https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/" }
        - { label: "Standard", url: "https://agent2agent.info/specification/" }
      what_it_solves: >-
        Interoperability between agents built by different vendors/frameworks: discovery,
        capability negotiation, task/message/artifact exchange.
      how_its_standardizing: >-
        Announced by Google; moved toward open governance. Adoption is driven by enterprise
        demand for multi-vendor agent composition and a shared â€œAgentCard + Taskâ€ model.
      virtuous_cycle:
        - "Enterprises can compose agents across vendors instead of buying a monolith."
        - "Vendors become more valuable by being interoperable, not isolated."
        - "A shared task/artifact model enables tooling (routers, registries, monitors)."

  # Instruction surfaces: extend right and spread vertically (not cramped)
  - id: agents-md
    title: AGENTS.md
    icon: images/icon-agents-md.png
    icon_alt: "#"
    tagline: Project-local guidance for agents
    layout: { x: 4.05, y: 1.95 }
    tree:
      depends_on: [tool-calling]
    detail:
      links:
        - { label: "Standard", url: "https://agents.md/" }
      what_it_solves: >-
        A predictable file in a repo that tells coding agents how to work here:
        setup, tests, style, and boundaries.
      how_its_standardizing: >-
        Emerged from practice (â€œput it in the READMEâ€), then formalized as a shared
        convention so any agent can look in the same place.
      virtuous_cycle:
        - "Repo maintainers write instructions once for all agent tools."
        - "Agent tools auto-discover guidance, reducing failures and friction."
        - "A shared convention encourages better repo hygiene for automation."

  - id: llms-txt
    title: llms.txt
    icon: images/icon-llms-txt.png
    icon_alt: "//"
    tagline: AI-readable site index
    layout: { x: 4.75, y: 2.60 }
    tree:
      depends_on: [tool-calling]
    detail:
      links:
        - { label: "Standard", url: "https://llmstxt.org/" }
      what_it_solves: >-
        A curated index for agents to find the right docs quickly, instead of crawling
        an entire website.
      how_its_standardizing: >-
        Proposed as a simple well-known path and Markdown format; standardized by adoption
        in docs platforms and generation tooling rather than a formal body.
      virtuous_cycle:
        - "Sites publish an index; agents spend fewer tokens and fetch fewer pages."
        - "Docs platforms add generators; adoption becomes near-zero effort."
        - "Agent tooling becomes more reliable across arbitrary sites."

  - id: agent-skills
    title: Agent Skills
    icon: images/icon-agent-skills.png
    icon_alt: "pkg"
    tagline: Portable capability packages
    layout: { x: 4.35, y: 3.35 }
    tree:
      depends_on: [tool-calling]
    detail:
      links:
        - { label: "Standard", url: "https://agentskills.io/specification" }
      what_it_solves: >-
        A portable package format for playbooks, references, and optional scripts
        that agents can load on demand.
      how_its_standardizing: >-
        Standardized by ecosystem support in major IDE/agent platforms and shared
        directory conventions (SKILL.md + assets/scripts).
      virtuous_cycle:
        - "Skill authors write once and reach many agent hosts."
        - "Hosts get a growing library of reusable procedures."
        - "Skills become a distribution channel for best practices."

  # â”€â”€ Domains â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: ucp
    title: UCP
    icon: images/icon-ucp.png
    icon_alt: "$"
    tagline: Universal agent commerce
    layout: { x: 5.10, y: 4.05 }
    tree:
      depends_on: [a2a]
    detail:
      links:
        - { label: "Standard", url: "https://www.shopify.com/ucp" }
      what_it_solves: >-
        Standardizes agent commerce flows across merchants: cart/checkout/purchase
        without custom integrations per store.
      how_its_standardizing: >-
        Maintained by Shopify and Google; adoption is driven by merchant platforms and
        payments ecosystem partners that benefit from a shared checkout interface.
      virtuous_cycle:
        - "Merchants implement once and accept many agents."
        - "Agents implement once and can shop broadly."
        - "Payments/logistics partners standardize integrations around a common flow."

  - id: agent-identity
    title: Agent Identity
    icon: images/icon-agent-identity.png
    icon_alt: "id"
    tagline: Verified agents on the open web
    layout: { x: 5.10, y: 5.05 }
    tree:
      depends_on: [a2a]
    detail:
      links:
        - { label: "Standard", url: "https://developer.visa.com/capabilities/trusted-agent-protocol/trusted-agent-protocol-specifications" }
      what_it_solves: >-
        Lets websites and merchants verify that requests come from an authorized agent,
        reducing reliance on CAPTCHAs, IP allowlists, and brittle bot heuristics.
      how_its_standardizing: >-
        Built on HTTP Message Signatures (IETF family) and implemented via vendor-led
        profiles (e.g., Web Bot Auth, Visa TAP). Standardization is profile convergence
        on shared signing and key-discovery patterns.
      virtuous_cycle:
        - "Sites can apply policy based on verified identity rather than guesswork."
        - "Agents get reliable access without adversarial bot mitigation."
        - "Commerce and high-trust domains get a shared trust substrate."

  # â”€â”€ Frontier (locked by default; â€œrocket shipâ€ unlocks) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: agent-audit
    title: Agent Audit Traces
    icon: images/icon-audit.png
    icon_alt: "âŽ”"
    tagline: Portable run records for debugging & accountability
    layout: { x: 6.30, y: 1.20 }
    unlock: { state: locked, class: frontier, icon: images/unlock-rocket.png }
    tree:
      depends_on: [tool-calling, mcp, a2a]
    detail:
      links:
        - { label: "Standard (substrate)", url: "https://opentelemetry.io/docs/concepts/signals/traces/" }
      what_it_solves: >-
        A standard event+artifact record of what an agent did (model calls, tool calls,
        browser actions, file writes) for replay, debugging, and incident response.
      how_its_standardizing: >-
        Likely to layer on OpenTelemetry-like traces with agent-specific event schemas,
        redaction, and artifact references.
      virtuous_cycle:
        - "Operators can debug and govern agents across vendors with one trace format."
        - "Vendors integrate once with monitoring and compliance tooling."
        - "Evaluations and safety reviews become reproducible and comparable."

  - id: intent-mandates
    title: Signed Intent Mandates
    icon: images/icon-mandate.png
    icon_alt: "âœ“"
    tagline: Verifiable consent + constraints for actions
    layout: { x: 6.30, y: 2.20 }
    unlock: { state: locked, class: frontier, icon: images/unlock-rocket.png }
    tree:
      depends_on: [agent-identity, a2a]
    detail:
      links:
        - { label: "Standard (payments example)", url: "https://ap2-protocol.org/specification/" }
      what_it_solves: >-
        A signed object binding user intent and constraints (scope, limits, TTL) to
        downstream agent actionsâ€”generalizing the â€œpayments mandateâ€ idea.
      how_its_standardizing: >-
        Expected to converge first in regulated domains (payments, IT ops, healthcare),
        then generalize to cross-domain consent receipts with standard fields.
      virtuous_cycle:
        - "Counterparties can rely on machine-verifiable authorization."
        - "Users get enforceable constraints instead of trusting opaque agents."
        - "Platforms interoperate on the same consent artifact across workflows."

  - id: agent-registries
    title: Agent Registries & Entitlements
    icon: images/icon-registry.png
    icon_alt: "dir"
    tagline: Discovery, routing, permissions, versions
    layout: { x: 6.30, y: 3.30 }
    unlock: { state: locked, class: frontier, icon: images/unlock-rocket.png }
    tree:
      depends_on: [a2a]
    detail:
      links:
        - { label: "Draft (example)", url: "https://datatracker.ietf.org/doc/draft-narvaneni-agent-uri/" }
      what_it_solves: >-
        A standard directory for agents: capability queries, routing, health/versioning,
        and enterprise entitlements.
      how_its_standardizing: >-
        Likely to emerge from a mix of well-known descriptors + enterprise catalogs, with
        A2A-style AgentCards as the basic metadata unit.
      virtuous_cycle:
        - "Enterprises can safely compose multi-vendor agent systems."
        - "Vendors plug into one directory surface instead of bespoke integrations."
        - "Governance (who can call what) becomes portable."

  - id: skill-security
    title: Skill Signing & Permission Manifests
    icon: images/icon-skill-security.png
    icon_alt: "ðŸ”’"
    tagline: Safe distribution of executable capabilities
    layout: { x: 6.30, y: 4.40 }
    unlock: { state: locked, class: frontier, icon: images/unlock-rocket.png }
    tree:
      depends_on: [agent-skills]
    detail:
      links:
        - { label: "Standard (inspiration)", url: "https://slsa.dev/" }
      what_it_solves: >-
        Prevents â€œmalicious or over-privileged skillsâ€ by standardizing: signing/provenance,
        declared permissions, sandbox expectations, and review metadata.
      how_its_standardizing: >-
        Likely to borrow from supply-chain frameworks (provenance + signing) and converge
        within agent skill ecosystems as marketplaces mature.
      virtuous_cycle:
        - "Users can trust skills based on provenance + declared permissions."
        - "Marketplaces reduce risk without bespoke vetting per host."
        - "Skill authors get a portable security envelope across platforms."