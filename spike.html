<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple L→R Tech Tree Layout</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #stage {
      position: relative;
      /* width/height set dynamically by render() */
      border: 1px solid #ddd;
      overflow: hidden;
      background:
        linear-gradient(#f6f6f6 1px, transparent 1px) 0 0 / 40px 40px,
        linear-gradient(90deg, #f6f6f6 1px, transparent 1px) 0 0 / 40px 40px,
        #fff;
    }
    .node {
      position: absolute;
      box-sizing: border-box;
      border: 2px solid #222;
      background: #cfe2f3;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 28px;
      user-select: none;
    }
    svg {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .edge {
      fill: none;
      stroke: #111;
      stroke-width: 2.5;
    }
  </style>
</head>
<body>

<div style="display:flex; gap:12px; align-items:center; margin: 10px 0;">
  <button id="case1">Case 1</button>
  <button id="case2">Case 2</button>
  <button id="case3">Case 3</button>
  <button id="case4">Case 4</button>
  <button id="case5">Case 5 (spread parents)</button>
  <button id="case6">Case 6 (multi-parent)</button>
  <button id="case7">Case 7 (skip-col clusters)</button>
</div>

<div id="stage">
  <svg id="wires">
    <defs>
      <marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
        <path d="M0,0 L12,6 L0,12 Z" fill="#111"></path>
      </marker>
    </defs>
  </svg>
</div>

<script>
  // ---------- Layout parameters ----------
  const cfg = {
    boxW: 260,
    boxH: 120,
    gapX: 220,
    gapY: 120,
    marginX: 40,
    marginY: 60,
  };

  // ---------- Example inputs (order defines vertical order) ----------
  const CASES = {
    case1: [
      { id: "A", label: "A", col: 0 },
      { id: "B", label: "B", col: 1, parent: "A" },
      { id: "C", label: "C", col: 2, parent: "A" },
      { id: "D", label: "D", col: 1, parent: "A" },
    ],
    case2: [
      { id: "A", label: "A", col: 0 },
      { id: "C", label: "C", col: 2, parent: "A" },
      { id: "B", label: "B", col: 1, parent: "A" },
      { id: "D", label: "D", col: 1, parent: "A" },
    ],
    case3: [
      { id: "A",  label: "A", col: 0 },
      { id: "C1", label: "C", col: 2, parent: "A" },
      { id: "C2", label: "C", col: 2, parent: "A" },
      { id: "C3", label: "C", col: 2, parent: "A" },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "D",  label: "D", col: 1, parent: "A" },
    ],
    case4: [
      { id: "A",  label: "A", col: 0 },
      { id: "C1", label: "C", col: 2, parent: "A" },
      { id: "C2", label: "C", col: 2, parent: "A" },
      { id: "C3", label: "C", col: 2, parent: "A" },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "D",  label: "D", col: 1, parent: "A" },
      { id: "E",  label: "E", col: 2, parent: "D" },
      { id: "F",  label: "F", col: 2, parent: "D" },
    ],
    // Case 5: Two parents with many children each — demonstrates need for "spread parents"
    // Current behavior: C's children get pushed down, arrows become long and overlapping
    // Desired behavior: B and C spread apart in col 1 so their children fit without pushing
    case5: [
      { id: "A",  label: "A", col: 0 },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "B1", label: "B1", col: 2, parent: "B" },
      { id: "B2", label: "B2", col: 2, parent: "B" },
      { id: "B3", label: "B3", col: 2, parent: "B" },
      { id: "C",  label: "C", col: 1, parent: "A" },
      { id: "C1", label: "C1", col: 2, parent: "C" },
      { id: "C2", label: "C2", col: 2, parent: "C" },
      { id: "C3", label: "C3", col: 2, parent: "C" },
    ],
    // Case 6: Multiple parents — child should center on the group of parents
    // Like: Tokenizers, Weight Formats, Embeddings, Chat Templates → Inference API
    case6: [
      { id: "P1", label: "P1", col: 0 },
      { id: "P2", label: "P2", col: 0 },
      { id: "P3", label: "P3", col: 0 },
      { id: "P4", label: "P4", col: 0 },
      { id: "X",  label: "X", col: 1, parents: ["P1", "P2", "P3", "P4"] },
      { id: "Y",  label: "Y", col: 2, parent: "X" },
      { id: "Z",  label: "Z", col: 2, parent: "X" },
    ],
    // Case 7: Skip-column edges with real nodes in between
    // Problem: All skip-col edges share one placeholder, causing visual confusion
    // when there's a real node (B, D) in the intermediate column
    // Desired: Separate placeholders for each "cluster" of skip-col children
    case7: [
      { id: "A",  label: "A", col: 0 },
      // First cluster: skip-col children BEFORE real node B
      { id: "C1", label: "C1", col: 2, parent: "A" },
      { id: "C2", label: "C2", col: 2, parent: "A" },
      // Real node B at col 1 — should visually separate the clusters
      { id: "B",  label: "B", col: 1, parent: "A" },
      // B's own children at col 2
      { id: "B1", label: "B1", col: 2, parent: "B" },
      // Second cluster: skip-col children AFTER real node B
      { id: "E1", label: "E1", col: 2, parent: "A" },
      { id: "E2", label: "E2", col: 2, parent: "A" },
      // Another real node D at col 1
      { id: "D",  label: "D", col: 1, parent: "A" },
      // Third cluster: skip-col children AFTER real node D
      { id: "F1", label: "F1", col: 2, parent: "A" },
    ],
  };

  // ---------- Core layout engine ----------
  // Algorithm:
  //   1. Create "placeholders" for edges that skip columns
  //   2. Compute "subtree height" for each node (right-to-left pass)
  //   3. Position nodes left-to-right, spacing siblings by subtree height
  //   4. Children stay centered on parents; parents spread to accommodate
  //   5. Multi-parent nodes center on the centroid of all parents
  
  // Helper: get array of parent IDs (supports both parent and parents)
  function getParentIds(n) {
    if (n.parents && n.parents.length) return n.parents;
    if (n.parent) return [n.parent];
    return [];
  }
  
  function computePositions(nodes) {
    const byId = new Map(nodes.map(n => [n.id, n]));
    
    // Step 1: Create placeholders for edges that span multiple columns
    // Key insight: create separate placeholders for each "cluster" of skip-col children
    // A new cluster starts when there's a real node between consecutive skip-col destinations
    
    const placeholders = [];
    const placeholderMap = new Map(); // "parentId-col-cluster" -> placeholder
    const nodeToPlaceholderCluster = new Map(); // "nodeId-parentId-col" -> cluster index
    
    // First, gather all skip-column edges grouped by (parent, intermediate col)
    // Each entry: { parentId, col, children: [{node, inputIdx}] }
    const skipEdgeGroups = new Map();
    
    nodes.forEach((n, inputIdx) => {
      const parentIds = getParentIds(n);
      for (const pid of parentIds) {
        const parent = byId.get(pid);
        if (!parent || n.col <= parent.col + 1) continue;
        
        // This edge needs placeholders at each intermediate column
        for (let col = parent.col + 1; col < n.col; col++) {
          const groupKey = `${pid}-${col}`;
          if (!skipEdgeGroups.has(groupKey)) {
            skipEdgeGroups.set(groupKey, { parentId: pid, col, children: [] });
          }
          skipEdgeGroups.get(groupKey).children.push({ node: n, inputIdx });
        }
      }
    });
    
    // Also collect real nodes at each column for cluster detection
    const realNodesAtCol = new Map();
    nodes.forEach((n, inputIdx) => {
      if (!realNodesAtCol.has(n.col)) realNodesAtCol.set(n.col, []);
      realNodesAtCol.get(n.col).push({ node: n, inputIdx });
    });
    
    // Now process each group to create clustered placeholders
    for (const [groupKey, group] of skipEdgeGroups) {
      const { parentId, col, children } = group;
      const realNodes = realNodesAtCol.get(col) || [];
      
      // Sort children by inputIdx
      children.sort((a, b) => a.inputIdx - b.inputIdx);
      
      // Sort real nodes by inputIdx  
      const sortedRealNodes = [...realNodes].sort((a, b) => a.inputIdx - b.inputIdx);
      
      // Assign cluster indices: increment cluster when a real node appears between consecutive children
      let clusterIdx = 0;
      let realNodePointer = 0;
      
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        
        // Check if any real node comes between this child and the previous one
        if (i > 0) {
          const prevChildIdx = children[i - 1].inputIdx;
          const currChildIdx = child.inputIdx;
          
          // Count real nodes between prev and curr
          while (realNodePointer < sortedRealNodes.length && 
                 sortedRealNodes[realNodePointer].inputIdx < currChildIdx) {
            if (sortedRealNodes[realNodePointer].inputIdx > prevChildIdx) {
              // Found a real node between prev and curr - start new cluster
              clusterIdx++;
              break;
            }
            realNodePointer++;
          }
        }
        
        // Record which cluster this node belongs to for this parent-col combo
        nodeToPlaceholderCluster.set(`${child.node.id}-${parentId}-${col}`, clusterIdx);
        
        // Create placeholder for this cluster if it doesn't exist
        const phKey = `${parentId}-${col}-${clusterIdx}`;
        if (!placeholderMap.has(phKey)) {
          const prevCol = col - 1;
          const prevPhKey = `${parentId}-${prevCol}-${clusterIdx}`;
          const parent = byId.get(parentId);
          
          placeholders.push({
            id: `ph-${phKey}`,
            col: col,
            parent: col === parent.col + 1 ? parentId : `ph-${prevPhKey}`,
            isPlaceholder: true,
            inputIdx: child.inputIdx, // Use first child's inputIdx for positioning
          });
          placeholderMap.set(phKey, placeholders[placeholders.length - 1]);
        }
      }
    }
    
    // Compute layoutParents: for each node, list of layout parent IDs
    // If node skips columns, use the cluster-specific placeholder in col-1 for that parent
    const layoutParents = new Map();
    nodes.forEach(n => {
      const parentIds = getParentIds(n);
      if (parentIds.length === 0) {
        layoutParents.set(n.id, []);
      } else {
        const lps = parentIds.map(pid => {
          const parent = byId.get(pid);
          if (parent && n.col > parent.col + 1) {
            // Look up the cluster index for this node-parent-col combo
            const clusterKey = `${n.id}-${pid}-${n.col - 1}`;
            const clusterIdx = nodeToPlaceholderCluster.get(clusterKey) || 0;
            return `ph-${pid}-${n.col - 1}-${clusterIdx}`;
          }
          return pid;
        });
        layoutParents.set(n.id, lps);
      }
    });
    
    const allItems = [
      ...nodes.map((n, i) => ({ ...n, inputIdx: i })),
      ...placeholders
    ];
    const allById = new Map(allItems.map(item => [item.id, item]));
    
    const columns = new Map();
    allItems.forEach(item => {
      if (!columns.has(item.col)) columns.set(item.col, []);
      columns.get(item.col).push(item);
    });
    
    // Sort each column by inputIdx to preserve input order
    columns.forEach(items => items.sort((a, b) => a.inputIdx - b.inputIdx));
    
    const sortedCols = [...columns.keys()].sort((a, b) => a - b);
    const maxCol = Math.max(...sortedCols);
    
    // Step 2: Build children map (parent -> children)
    // For single-parent nodes, they are children of that parent
    // For multi-parent nodes, they contribute to each parent's children list
    const childrenOf = new Map();
    allItems.forEach(item => {
      const lps = layoutParents.get(item.id) || (item.parent ? [item.parent] : []);
      for (const pid of lps) {
        if (!childrenOf.has(pid)) childrenOf.set(pid, []);
        childrenOf.get(pid).push(item);
      }
    });
    
    // Step 3: Compute subtree height for each node (right-to-left)
    // For multi-parent children, we count them once (not per parent)
    const subtreeHeight = new Map();
    
    for (let col = maxCol; col >= 0; col--) {
      const items = columns.get(col) || [];
      for (const item of items) {
        const children = childrenOf.get(item.id) || [];
        // Filter to children with this as their ONLY layout parent (single-parent case)
        // Multi-parent children are positioned separately
        const singleParentChildren = children.filter(c => {
          const lps = layoutParents.get(c.id) || (c.parent ? [c.parent] : []);
          return lps.length === 1;
        });
        
        if (singleParentChildren.length === 0) {
          subtreeHeight.set(item.id, cfg.boxH);
        } else {
          const childHeights = singleParentChildren.map(c => subtreeHeight.get(c.id) || cfg.boxH);
          const totalHeight = childHeights.reduce((sum, h) => sum + h, 0) + (singleParentChildren.length - 1) * cfg.gapY;
          subtreeHeight.set(item.id, totalHeight);
        }
      }
    }
    
    // Step 4: Position nodes left-to-right
    const relY = new Map();
    
    for (const col of sortedCols) {
      const items = columns.get(col);
      
      // Separate items into: single-parent (grouped by parent) and multi-parent (own group each)
      const singleParentItems = [];
      const multiParentItems = [];
      
      items.forEach(item => {
        const lps = layoutParents.get(item.id) || (item.parent ? [item.parent] : []);
        if (lps.length <= 1) {
          singleParentItems.push(item);
        } else {
          multiParentItems.push(item);
        }
      });
      
      // Group single-parent items by their parent
      const byParent = new Map();
      singleParentItems.forEach(item => {
        const lps = layoutParents.get(item.id) || (item.parent ? [item.parent] : []);
        const pid = lps[0] || "__root__";
        if (!byParent.has(pid)) byParent.set(pid, []);
        byParent.get(pid).push(item);
      });
      
      // Position single-parent groups centered around their parent
      for (const [pid, group] of byParent) {
        const parentCenterY = (pid !== "__root__" && relY.has(pid)) ? relY.get(pid) : 0;
        
        const heights = group.map(item => subtreeHeight.get(item.id) || cfg.boxH);
        const totalSpan = heights.reduce((sum, h) => sum + h, 0) + (group.length - 1) * cfg.gapY;
        
        let currentY = parentCenterY - totalSpan / 2;
        group.forEach((item, i) => {
          const h = heights[i];
          relY.set(item.id, currentY + h / 2);
          currentY += h + cfg.gapY;
        });
      }
      
      // Position multi-parent items centered on centroid of all parents
      multiParentItems.forEach(item => {
        const lps = layoutParents.get(item.id) || [];
        const parentYs = lps.map(pid => relY.get(pid)).filter(y => y !== undefined);
        if (parentYs.length > 0) {
          const centroidY = parentYs.reduce((sum, y) => sum + y, 0) / parentYs.length;
          relY.set(item.id, centroidY);
        } else {
          relY.set(item.id, 0);
        }
      });
      
      // Collision resolution: sort ALL items by inputIdx
      const allColItems = [...items].sort((a, b) => a.inputIdx - b.inputIdx);
      
      // Push items down if they overlap with previous
      for (let i = 1; i < allColItems.length; i++) {
        const prev = allColItems[i - 1];
        const curr = allColItems[i];
        
        const prevBottom = relY.get(prev.id) + (subtreeHeight.get(prev.id) || cfg.boxH) / 2;
        const currTop = relY.get(curr.id) - (subtreeHeight.get(curr.id) || cfg.boxH) / 2;
        const overlap = prevBottom + cfg.gapY - currTop;
        
        if (overlap > 0) {
          // Push this and all subsequent items down
          for (let j = i; j < allColItems.length; j++) {
            relY.set(allColItems[j].id, relY.get(allColItems[j].id) + overlap);
          }
        }
      }
    }
    
    // Step 5: Convert relative positions to absolute canvas positions
    let minRelY = Infinity;
    relY.forEach(y => { minRelY = Math.min(minRelY, y); });
    
    const offsetY = cfg.marginY + cfg.boxH / 2 - minRelY;
    
    const pos = new Map();
    allItems.forEach(item => {
      const centerY = relY.get(item.id);
      const x = cfg.marginX + item.col * (cfg.boxW + cfg.gapX);
      const y = centerY + offsetY - cfg.boxH / 2;
      pos.set(item.id, { 
        x, y, 
        col: item.col, 
        isPlaceholder: item.isPlaceholder,
        centerY: centerY + offsetY
      });
    });
    
    return { pos, nodeToPlaceholderCluster };
  }

  function midRight(p) { return { x: p.x + cfg.boxW, y: p.centerY }; }
  function midLeft(p)  { return { x: p.x,          y: p.centerY }; }

  function betweenColsX(colA, colB) {
    // midpoint x between the right edge of colA and left edge of colB
    const xRightA = cfg.marginX + colA * (cfg.boxW + cfg.gapX) + cfg.boxW;
    const xLeftB  = cfg.marginX + colB * (cfg.boxW + cfg.gapX);
    return (xRightA + xLeftB) / 2;
  }

  function routeEdge(pNode, cNode, pos, nodeToPlaceholderCluster) {
    const p = pos.get(pNode.id);
    const c = pos.get(cNode.id);
    const S = midRight(p);
    const E = midLeft(c);

    // Build orthogonal polyline through any placeholders
    const pts = [S];
    
    // Collect waypoints: placeholders in intermediate columns (cluster-specific)
    const waypoints = [];
    for (let col = p.col + 1; col < c.col; col++) {
      // Look up the cluster index for this specific edge
      const clusterKey = `${cNode.id}-${pNode.id}-${col}`;
      const clusterIdx = nodeToPlaceholderCluster.get(clusterKey) || 0;
      const phId = `ph-${pNode.id}-${col}-${clusterIdx}`;
      if (pos.has(phId)) {
        waypoints.push(pos.get(phId));
      }
    }
    
    if (waypoints.length === 0) {
      // Direct connection: horizontal from parent, vertical bend, horizontal to child
      const xHop = betweenColsX(p.col, c.col);
      pts.push({ x: xHop, y: S.y });
      pts.push({ x: xHop, y: E.y });
    } else {
      // Route through placeholders
      let prevY = S.y;
      
      for (let i = 0; i < waypoints.length; i++) {
        const wp = waypoints[i];
        const xHop = betweenColsX(wp.col - 1, wp.col);
        
        // Horizontal to the hop point at previous Y
        pts.push({ x: xHop, y: prevY });
        // Vertical to waypoint's Y
        pts.push({ x: xHop, y: wp.centerY });
        
        prevY = wp.centerY;
      }
      
      // Final segment to child
      const lastWp = waypoints[waypoints.length - 1];
      const xHop = betweenColsX(lastWp.col, c.col);
      pts.push({ x: xHop, y: prevY });
      pts.push({ x: xHop, y: E.y });
    }

    pts.push(E);
    return pts;
  }

  function polylinePath(points) {
    // SVG path "M x,y L x,y ..."
    return points.map((pt, i) => (i === 0 ? `M ${pt.x},${pt.y}` : `L ${pt.x},${pt.y}`)).join(" ");
  }

  function render(nodes) {
    const stage = document.getElementById("stage");
    const wires = document.getElementById("wires");

    // Clear old nodes (keep the SVG defs)
    [...stage.querySelectorAll(".node")].forEach(el => el.remove());
    [...wires.querySelectorAll("path.edge")].forEach(el => el.remove());

    const { pos, nodeToPlaceholderCluster } = computePositions(nodes);
    const byId = new Map(nodes.map(n => [n.id, n]));

    // Auto-size stage to fit all real nodes (not placeholders)
    let maxX = 0, maxY = 0;
    pos.forEach(p => {
      if (p.isPlaceholder) return;
      maxX = Math.max(maxX, p.x + cfg.boxW);
      maxY = Math.max(maxY, p.y + cfg.boxH);
    });
    stage.style.width  = (maxX + cfg.marginX) + "px";
    stage.style.height = (maxY + cfg.marginY) + "px";

    // Render nodes (not placeholders)
    nodes.forEach(n => {
      const p = pos.get(n.id);
      const el = document.createElement("div");
      el.className = "node";
      el.style.width = cfg.boxW + "px";
      el.style.height = cfg.boxH + "px";
      el.style.left = p.x + "px";
      el.style.top = p.y + "px";
      el.textContent = n.label;
      stage.appendChild(el);
    });

    // Render edges (support multiple parents)
    nodes.forEach(n => {
      const parentIds = getParentIds(n);
      for (const pid of parentIds) {
        const parent = byId.get(pid);
        if (!parent) continue;

        const pts = routeEdge(parent, n, pos, nodeToPlaceholderCluster);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("class", "edge");
        path.setAttribute("marker-end", "url(#arrow)");
        path.setAttribute("d", polylinePath(pts));
        wires.appendChild(path);
      }
    });
  }

  // Buttons
  document.getElementById("case1").onclick = () => render(CASES.case1);
  document.getElementById("case2").onclick = () => render(CASES.case2);
  document.getElementById("case3").onclick = () => render(CASES.case3);
  document.getElementById("case4").onclick = () => render(CASES.case4);
  document.getElementById("case5").onclick = () => render(CASES.case5);
  document.getElementById("case6").onclick = () => render(CASES.case6);
  document.getElementById("case7").onclick = () => render(CASES.case7);

  // Initial
  render(CASES.case7);
</script>

</body>
</html>