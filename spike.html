<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple L→R Tech Tree Layout</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #stage {
      position: relative;
      border: 1px solid #ddd;
      overflow: hidden;
      background:
        linear-gradient(#f6f6f6 1px, transparent 1px) 0 0 / 40px 40px,
        linear-gradient(90deg, #f6f6f6 1px, transparent 1px) 0 0 / 40px 40px,
        #fff;
    }
    .node {
      position: absolute;
      box-sizing: border-box;
      border: 2px solid #222;
      background: #cfe2f3;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 28px;
      user-select: none;
    }
    .cluster-box {
      position: absolute;
      box-sizing: border-box;
      border: 2px dashed #888;
      background: rgba(200, 200, 200, 0.1);
      border-radius: 2px;
    }
    .cluster-box .cluster-label {
      position: absolute;
      top: -10px;
      left: 8px;
      background: #fff;
      padding: 0 4px;
      font-size: 11px;
      font-weight: 600;
      color: #888;
      text-transform: uppercase;
    }
    svg {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .edge {
      fill: none;
      stroke: #111;
      stroke-width: 2.5;
    }
  </style>
</head>
<body>

<div style="display:flex; gap:12px; align-items:center; margin: 10px 0; flex-wrap: wrap;">
  <button id="case1">Case 1</button>
  <button id="case2">Case 2</button>
  <button id="case3">Case 3</button>
  <button id="case4">Case 4</button>
  <button id="case5">Case 5 (spread parents)</button>
  <button id="case6">Case 6 (multi-parent)</button>
  <button id="case7">Case 7 (skip-col clusters)</button>
  <button id="case8">Case 8 (first-class cluster)</button>
  <button id="case9">Case 9 (cluster child has children)</button>
  <button id="case10">Case 10 (full scenario)</button>
  <button id="case11" style="background:#ffd;">Case 11 (skip-col bloat)</button>
</div>

<div id="stage">
  <svg id="wires">
    <defs>
      <marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
        <path d="M0,0 L12,6 L0,12 Z" fill="#111"></path>
      </marker>
    </defs>
  </svg>
</div>

<script>
  // ---------- Layout parameters ----------
  const cfg = {
    boxW: 260,
    boxH: 120,
    gapX: 220,
    gapY: 120,
    marginX: 40,
    marginY: 60,
    clusterPad: 14,
  };

  // ---------- Example inputs ----------
  const CASES = {
    case1: [
      { id: "A", label: "A", col: 0 },
      { id: "B", label: "B", col: 1, parent: "A" },
      { id: "C", label: "C", col: 2, parent: "A" },
      { id: "D", label: "D", col: 1, parent: "A" },
    ],
    case2: [
      { id: "A", label: "A", col: 0 },
      { id: "C", label: "C", col: 2, parent: "A" },
      { id: "B", label: "B", col: 1, parent: "A" },
      { id: "D", label: "D", col: 1, parent: "A" },
    ],
    case3: [
      { id: "A",  label: "A", col: 0 },
      { id: "C1", label: "C", col: 2, parent: "A" },
      { id: "C2", label: "C", col: 2, parent: "A" },
      { id: "C3", label: "C", col: 2, parent: "A" },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "D",  label: "D", col: 1, parent: "A" },
    ],
    case4: [
      { id: "A",  label: "A", col: 0 },
      { id: "C1", label: "C", col: 2, parent: "A" },
      { id: "C2", label: "C", col: 2, parent: "A" },
      { id: "C3", label: "C", col: 2, parent: "A" },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "D",  label: "D", col: 1, parent: "A" },
      { id: "E",  label: "E", col: 2, parent: "D" },
      { id: "F",  label: "F", col: 2, parent: "D" },
    ],
    case5: [
      { id: "A",  label: "A", col: 0 },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "B1", label: "B1", col: 2, parent: "B" },
      { id: "B2", label: "B2", col: 2, parent: "B" },
      { id: "B3", label: "B3", col: 2, parent: "B" },
      { id: "C",  label: "C", col: 1, parent: "A" },
      { id: "C1", label: "C1", col: 2, parent: "C" },
      { id: "C2", label: "C2", col: 2, parent: "C" },
      { id: "C3", label: "C3", col: 2, parent: "C" },
    ],
    case6: [
      { id: "P1", label: "P1", col: 0 },
      { id: "P2", label: "P2", col: 0 },
      { id: "P3", label: "P3", col: 0 },
      { id: "P4", label: "P4", col: 0 },
      { id: "X",  label: "X", col: 1, parents: ["P1", "P2", "P3", "P4"] },
      { id: "Y",  label: "Y", col: 2, parent: "X" },
      { id: "Z",  label: "Z", col: 2, parent: "X" },
    ],
    case7: [
      { id: "A",  label: "A", col: 0 },
      { id: "C1", label: "C1", col: 2, parent: "A" },
      { id: "C2", label: "C2", col: 2, parent: "A" },
      { id: "B",  label: "B", col: 1, parent: "A" },
      { id: "B1", label: "B1", col: 2, parent: "B" },
      { id: "E1", label: "E1", col: 2, parent: "A" },
      { id: "E2", label: "E2", col: 2, parent: "A" },
      { id: "D",  label: "D", col: 1, parent: "A" },
      { id: "F1", label: "F1", col: 2, parent: "A" },
    ],

    // ── NEW: First-class cluster cases ──

    // Case 8: Basic cluster as parent
    // Cluster CL contains P1-P4 at col 0, arrow from CL -> X
    case8: [
      { id: "CL", label: "CL", col: 0, cluster: true,
        items: [
          { id: "P1", label: "P1" },
          { id: "P2", label: "P2" },
          { id: "P3", label: "P3" },
          { id: "P4", label: "P4" },
        ]},
      { id: "X",  label: "X", col: 1, parent: "CL" },
      { id: "Y",  label: "Y", col: 2, parent: "X" },
      { id: "Z",  label: "Z", col: 2, parent: "X" },
    ],

    // Case 9: Cluster where an item has its own children
    // CL contains P1, P2. P2 has a child Q at col 2.
    // CL as a whole is a child of A. CL's cluster arrow -> X at col 2.
    // P2's item arrow -> Q at col 2.
    case9: [
      { id: "A", label: "A", col: 0 },
      { id: "CL", label: "CL", col: 1, parent: "A", cluster: true,
        items: [
          { id: "P1", label: "P1" },
          { id: "P2", label: "P2" },
        ]},
      { id: "X",  label: "X", col: 2, parent: "CL" },
      { id: "Q",  label: "Q", col: 2, parent: "P2" },
    ],

    // Case 10: Full scenario matching the real data
    // c-foundations (cluster, col 0) with 4 items -> inference-api (col 1)
    // inference-api -> tool-calling -> ... -> a2a
    // a2a -> c-domain (cluster, col shifted) with ucp, agent-identity
    // agent-identity -> ap2 -> intent-mandates
    case10: [
      { id: "c-found", label: "FOUNDATIONS", col: 0, cluster: true,
        items: [
          { id: "tok",  label: "Tokenizers" },
          { id: "wt",   label: "Weights" },
          { id: "emb",  label: "Embeddings" },
          { id: "chat", label: "Chat Tpl" },
        ]},
      { id: "inf",  label: "Inference API", col: 1, parent: "c-found" },
      { id: "tc",   label: "Tool Calling", col: 2, parent: "inf" },
      { id: "al",   label: "Agent Loop", col: 3, parent: "tc" },
      { id: "a2a",  label: "A2A", col: 4, parent: "al" },
      { id: "c-dom", label: "DOMAIN", col: 5, parent: "a2a", cluster: true,
        items: [
          { id: "ucp",  label: "UCP" },
          { id: "aid",  label: "Agent Identity" },
        ]},
      { id: "ap2",  label: "AP2", col: 6, parent: "aid" },
      { id: "mand", label: "Mandates", col: 7, parent: "ap2" },
    ],

    // Case 11: Skip-column placeholder bloats vertical space
    // Mirrors real layout: tool-calling has children mcp, standard-tools (col 1),
    // and agent-loop (col 2, skips col 1). Agent-loop has many children.
    // BUG: The placeholder for agent-loop in col 1 claims agent-loop's full
    // subtree height, pushing mcp and standard-tools apart even though
    // agent-loop's subtree lives in cols 2+, not col 1.
    case11: [
      { id: "TC",  label: "Tool Calling", col: 0 },
      // Col 1 children
      { id: "MCP", label: "MCP", col: 1, parent: "TC" },
      { id: "MCP1", label: "MCP Apps", col: 2, parent: "MCP" },
      { id: "ST",  label: "Std Tools", col: 1, parent: "TC" },
      { id: "ST1", label: "agents.md", col: 2, parent: "ST" },
      { id: "ST2", label: "llms.txt", col: 2, parent: "ST" },
      // Col 2 child (skip col 1) — has big subtree
      { id: "AL",  label: "Agent Loop", col: 2, parent: "TC" },
      { id: "AL1", label: "Skills", col: 3, parent: "AL" },
      { id: "AL2", label: "A2A", col: 3, parent: "AL" },
      { id: "AL3", label: "Audit", col: 3, parent: "AL" },
      { id: "AL4", label: "Card", col: 3, parent: "AL" },
      { id: "AL5", label: "Lingua", col: 3, parent: "AL" },
      { id: "AL6", label: "HCP", col: 3, parent: "AL" },
    ],
  };

  // ---------- Core layout engine ----------

  // Helper: get array of parent IDs (supports both parent and parents)
  function getParentIds(n) {
    if (n.parents && n.parents.length) return n.parents;
    if (n.parent) return [n.parent];
    return [];
  }

  // Expand clusters: flatten cluster nodes into their items + a cluster metadata entry.
  // Returns { expandedNodes, clusterMeta[] }
  // Each item gets the cluster's col. The cluster itself is removed from the node list
  // but tracked in clusterMeta for rendering the bounding box and routing cluster-level edges.
  function expandClusters(inputNodes) {
    const expandedNodes = [];
    const clusterMeta = []; // { id, label, col, itemIds[], parentIds[], childIds[] }

    for (const node of inputNodes) {
      if (node.cluster && node.items) {
        const parentIds = getParentIds(node);
        const itemIds = node.items.map(it => it.id);

        clusterMeta.push({
          id: node.id,
          label: node.label,
          col: node.col,
          itemIds,
          parentIds,
        });

        // Emit each item as a regular node in the cluster's column
        for (const item of node.items) {
          expandedNodes.push({
            id: item.id,
            label: item.label,
            col: node.col,
            // Items don't have a parent in the tree — they're positioned
            // within the cluster's vertical span
            _clusterId: node.id,
          });
        }
      } else {
        expandedNodes.push({ ...node });
      }
    }

    return { expandedNodes, clusterMeta };
  }

  function computePositions(inputNodes) {
    // Phase 0: Expand clusters
    const { expandedNodes, clusterMeta } = expandClusters(inputNodes);
    const nodes = expandedNodes;

    const byId = new Map(nodes.map(n => [n.id, n]));
    const clusterById = new Map(clusterMeta.map(c => [c.id, c]));

    // Build a lookup: item id -> cluster id
    const itemToCluster = new Map();
    for (const cm of clusterMeta) {
      for (const itemId of cm.itemIds) {
        itemToCluster.set(itemId, cm.id);
      }
    }

    // Resolve parent references that point to a cluster id:
    // If a node says parent: "CL" and CL is a cluster, we don't change
    // the parent — we'll handle it specially during positioning.
    // But we need to track cluster-level vs item-level edges.

    // Classify edges:
    //   - cluster-level parent: node.parent is a cluster id
    //   - item-level parent: node.parent is an item within a cluster (or a regular node)
    //   - cluster-level child: a cluster's children (nodes whose parent is the cluster id)

    // For layout purposes, nodes whose parent is a cluster will be positioned
    // relative to the cluster's center. Nodes whose parent is an item will be
    // positioned relative to that item.

    // Step 1: Create placeholders for edges that span multiple columns
    const placeholders = [];
    const placeholderMap = new Map();
    const nodeToPlaceholderCluster = new Map();

    const skipEdgeGroups = new Map();

    nodes.forEach((n, inputIdx) => {
      const parentIds = getParentIds(n);
      for (const pid of parentIds) {
        // Resolve the parent's column: might be a cluster or a node
        let parentCol;
        if (clusterById.has(pid)) {
          parentCol = clusterById.get(pid).col;
        } else if (byId.has(pid)) {
          parentCol = byId.get(pid).col;
        } else {
          continue;
        }

        if (n.col <= parentCol + 1) continue;

        for (let col = parentCol + 1; col < n.col; col++) {
          const groupKey = `${pid}-${col}`;
          if (!skipEdgeGroups.has(groupKey)) {
            skipEdgeGroups.set(groupKey, { parentId: pid, parentCol, col, children: [] });
          }
          skipEdgeGroups.get(groupKey).children.push({ node: n, inputIdx });
        }
      }
    });

    const realNodesAtCol = new Map();
    nodes.forEach((n, inputIdx) => {
      if (!realNodesAtCol.has(n.col)) realNodesAtCol.set(n.col, []);
      realNodesAtCol.get(n.col).push({ node: n, inputIdx });
    });

    for (const [groupKey, group] of skipEdgeGroups) {
      const { parentId, parentCol, col, children } = group;
      const realNodes = realNodesAtCol.get(col) || [];

      children.sort((a, b) => a.inputIdx - b.inputIdx);
      const sortedRealNodes = [...realNodes].sort((a, b) => a.inputIdx - b.inputIdx);

      let clusterIdx = 0;
      let realNodePointer = 0;

      for (let i = 0; i < children.length; i++) {
        const child = children[i];

        if (i > 0) {
          const prevChildIdx = children[i - 1].inputIdx;
          const currChildIdx = child.inputIdx;

          while (realNodePointer < sortedRealNodes.length &&
                 sortedRealNodes[realNodePointer].inputIdx < currChildIdx) {
            if (sortedRealNodes[realNodePointer].inputIdx > prevChildIdx) {
              clusterIdx++;
              break;
            }
            realNodePointer++;
          }
        }

        nodeToPlaceholderCluster.set(`${child.node.id}-${parentId}-${col}`, clusterIdx);

        const phKey = `${parentId}-${col}-${clusterIdx}`;
        if (!placeholderMap.has(phKey)) {
          const prevPhKey = `${parentId}-${col - 1}-${clusterIdx}`;

          placeholders.push({
            id: `ph-${phKey}`,
            col: col,
            parent: col === parentCol + 1 ? parentId : `ph-${prevPhKey}`,
            isPlaceholder: true,
            inputIdx: child.inputIdx,
          });
          placeholderMap.set(phKey, placeholders[placeholders.length - 1]);
        }
      }
    }

    // layoutParents: for each expanded node, its layout parent IDs
    const layoutParents = new Map();
    nodes.forEach(n => {
      const parentIds = getParentIds(n);
      if (parentIds.length === 0) {
        layoutParents.set(n.id, []);
      } else {
        const lps = parentIds.map(pid => {
          let parentCol;
          if (clusterById.has(pid)) parentCol = clusterById.get(pid).col;
          else if (byId.has(pid)) parentCol = byId.get(pid).col;
          else return pid;

          if (n.col > parentCol + 1) {
            const clusterKey = `${n.id}-${pid}-${n.col - 1}`;
            const ci = nodeToPlaceholderCluster.get(clusterKey) || 0;
            return `ph-${pid}-${n.col - 1}-${ci}`;
          }
          return pid;
        });
        layoutParents.set(n.id, lps);
      }
    });

    const allItems = [
      ...nodes.map((n, i) => ({ ...n, inputIdx: i })),
      ...placeholders
    ];

    const columns = new Map();
    allItems.forEach(item => {
      const col = item.col;
      if (!columns.has(col)) columns.set(col, []);
      columns.get(col).push(item);
    });

    columns.forEach(items => items.sort((a, b) => a.inputIdx - b.inputIdx));

    const sortedCols = [...columns.keys()].sort((a, b) => a - b);
    const maxCol = Math.max(...sortedCols);

    // Build children map
    const childrenOf = new Map();
    allItems.forEach(item => {
      const lps = layoutParents.get(item.id) || (item.parent ? [item.parent] : []);
      for (const pid of lps) {
        if (!childrenOf.has(pid)) childrenOf.set(pid, []);
        childrenOf.get(pid).push(item);
      }
    });

    // Step 3: Compute subtree height (right-to-left)
    const subtreeHeight = new Map();

    for (let col = maxCol; col >= 0; col--) {
      const items = columns.get(col) || [];
      for (const item of items) {
        const children = childrenOf.get(item.id) || [];
        const singleParentChildren = children.filter(c => {
          const lps = layoutParents.get(c.id) || (c.parent ? [c.parent] : []);
          return lps.length === 1;
        });

        if (singleParentChildren.length === 0) {
          subtreeHeight.set(item.id, cfg.boxH);
        } else if (item.isPlaceholder) {
          // Placeholders are invisible routing waypoints. Their subtree
          // lives in later columns, so don't claim that vertical space
          // in the intermediate column — just take one box height.
          subtreeHeight.set(item.id, cfg.boxH);
        } else {
          const childHeights = singleParentChildren.map(c => subtreeHeight.get(c.id) || cfg.boxH);
          const totalHeight = childHeights.reduce((sum, h) => sum + h, 0) + (singleParentChildren.length - 1) * cfg.gapY;
          subtreeHeight.set(item.id, totalHeight);
        }
      }
    }

    // For clusters: compute cluster subtree height = sum of item subtree heights + gaps
    // Then set a virtual subtreeHeight for the cluster id (used by nodes parented to the cluster)
    for (const cm of clusterMeta) {
      const itemHeights = cm.itemIds.map(id => subtreeHeight.get(id) || cfg.boxH);
      const clusterH = itemHeights.reduce((sum, h) => sum + h, 0) + (cm.itemIds.length - 1) * cfg.gapY;
      subtreeHeight.set(cm.id, clusterH);
    }

    // Step 4: Position nodes left-to-right
    const relY = new Map();

    // First, position cluster items as a group.
    // Clusters that have a parent in the tree get centered on that parent.
    // Root clusters center on 0.
    for (const cm of clusterMeta) {
      // Find the cluster's parent center
      let parentCenterY = 0;
      if (cm.parentIds.length > 0) {
        const pys = cm.parentIds.map(pid => relY.get(pid)).filter(y => y !== undefined);
        if (pys.length > 0) {
          parentCenterY = pys.reduce((a, b) => a + b, 0) / pys.length;
        }
      }

      // Stack items vertically centered on parentCenterY
      const itemHeights = cm.itemIds.map(id => subtreeHeight.get(id) || cfg.boxH);
      const totalSpan = itemHeights.reduce((sum, h) => sum + h, 0) + (cm.itemIds.length - 1) * cfg.gapY;

      let currentY = parentCenterY - totalSpan / 2;
      cm.itemIds.forEach((itemId, i) => {
        const h = itemHeights[i];
        relY.set(itemId, currentY + h / 2);
        currentY += h + cfg.gapY;
      });

      // Set the cluster's own center Y (for edges that target the cluster as a whole)
      const firstItemY = relY.get(cm.itemIds[0]);
      const lastItemY = relY.get(cm.itemIds[cm.itemIds.length - 1]);
      relY.set(cm.id, (firstItemY + lastItemY) / 2);
    }

    for (const col of sortedCols) {
      const items = columns.get(col);

      const singleParentItems = [];
      const multiParentItems = [];

      items.forEach(item => {
        // Skip cluster items — already positioned above
        if (item._clusterId) return;

        const lps = layoutParents.get(item.id) || (item.parent ? [item.parent] : []);
        if (lps.length <= 1) {
          singleParentItems.push(item);
        } else {
          multiParentItems.push(item);
        }
      });

      // Group single-parent items by their parent
      const byParent = new Map();
      singleParentItems.forEach(item => {
        const lps = layoutParents.get(item.id) || (item.parent ? [item.parent] : []);
        const pid = lps[0] || "__root__";
        if (!byParent.has(pid)) byParent.set(pid, []);
        byParent.get(pid).push(item);
      });

      for (const [pid, group] of byParent) {
        const parentCenterY = (pid !== "__root__" && relY.has(pid)) ? relY.get(pid) : 0;

        const heights = group.map(item => subtreeHeight.get(item.id) || cfg.boxH);
        const totalSpan = heights.reduce((sum, h) => sum + h, 0) + (group.length - 1) * cfg.gapY;

        let currentY = parentCenterY - totalSpan / 2;
        group.forEach((item, i) => {
          const h = heights[i];
          relY.set(item.id, currentY + h / 2);
          currentY += h + cfg.gapY;
        });
      }

      multiParentItems.forEach(item => {
        const lps = layoutParents.get(item.id) || [];
        const parentYs = lps.map(pid => relY.get(pid)).filter(y => y !== undefined);
        if (parentYs.length > 0) {
          const centroidY = parentYs.reduce((sum, y) => sum + y, 0) / parentYs.length;
          relY.set(item.id, centroidY);
        } else {
          relY.set(item.id, 0);
        }
      });

      // Collision resolution for ALL items in this column (including cluster items)
      const allColItems = [...items].sort((a, b) => a.inputIdx - b.inputIdx);

      for (let i = 1; i < allColItems.length; i++) {
        const prev = allColItems[i - 1];
        const curr = allColItems[i];

        // Use boxH (not subtreeHeight) for collision resolution.
        // Subtree heights already handled spacing during the positioning
        // phase; collision resolution just prevents box-to-box overlaps
        // between nodes from different parents sharing a column.
        const prevBottom = relY.get(prev.id) + cfg.boxH / 2;
        const currTop = relY.get(curr.id) - cfg.boxH / 2;
        const overlap = prevBottom + cfg.gapY - currTop;

        if (overlap > 0) {
          for (let j = i; j < allColItems.length; j++) {
            relY.set(allColItems[j].id, relY.get(allColItems[j].id) + overlap);
          }
        }
      }
    }

    // Update cluster center Y after collision resolution
    for (const cm of clusterMeta) {
      const firstItemY = relY.get(cm.itemIds[0]);
      const lastItemY = relY.get(cm.itemIds[cm.itemIds.length - 1]);
      relY.set(cm.id, (firstItemY + lastItemY) / 2);
    }

    // Step 5: Convert to absolute positions
    let minRelY = Infinity;
    relY.forEach(y => { if (isFinite(y)) minRelY = Math.min(minRelY, y); });

    const offsetY = cfg.marginY + cfg.boxH / 2 - minRelY;

    const pos = new Map();
    allItems.forEach(item => {
      const centerY = relY.get(item.id);
      if (centerY === undefined) return;
      const x = cfg.marginX + item.col * (cfg.boxW + cfg.gapX);
      const y = centerY + offsetY - cfg.boxH / 2;
      pos.set(item.id, {
        x, y,
        col: item.col,
        isPlaceholder: item.isPlaceholder,
        isClusterItem: !!item._clusterId,
        centerY: centerY + offsetY
      });
    });

    // Also store cluster center positions (for edge routing to/from clusters)
    for (const cm of clusterMeta) {
      const centerY = relY.get(cm.id) + offsetY;
      const x = cfg.marginX + cm.col * (cfg.boxW + cfg.gapX);
      // Compute bounding box from items
      const itemPositions = cm.itemIds.map(id => pos.get(id)).filter(Boolean);
      const minY = Math.min(...itemPositions.map(p => p.y));
      const maxY = Math.max(...itemPositions.map(p => p.y + cfg.boxH));
      pos.set(cm.id, {
        x: x - cfg.clusterPad,
        y: minY - cfg.clusterPad,
        col: cm.col,
        isCluster: true,
        centerY: centerY,
        clusterW: cfg.boxW + cfg.clusterPad * 2,
        clusterH: (maxY - minY) + cfg.clusterPad * 2,
        // For edge routing, midRight/midLeft use the node box edges
        // Cluster edges attach to the cluster bounding box
        clusterRight: x + cfg.boxW + cfg.clusterPad,
        clusterLeft: x - cfg.clusterPad,
      });
    }

    return { pos, nodeToPlaceholderCluster, clusterMeta, expandedNodes };
  }

  function midRight(p) {
    if (p.isCluster) return { x: p.clusterRight, y: p.centerY };
    return { x: p.x + cfg.boxW, y: p.centerY };
  }
  function midLeft(p) {
    if (p.isCluster) return { x: p.clusterLeft, y: p.centerY };
    return { x: p.x, y: p.centerY };
  }

  function betweenColsX(colA, colB) {
    const xRightA = cfg.marginX + colA * (cfg.boxW + cfg.gapX) + cfg.boxW;
    const xLeftB  = cfg.marginX + colB * (cfg.boxW + cfg.gapX);
    return (xRightA + xLeftB) / 2;
  }

  function routeEdge(parentId, childId, pos, nodeToPlaceholderCluster) {
    const p = pos.get(parentId);
    const c = pos.get(childId);
    if (!p || !c) return [];
    const S = midRight(p);
    const E = midLeft(c);

    const pts = [S];

    const waypoints = [];
    for (let col = p.col + 1; col < c.col; col++) {
      const clusterKey = `${childId}-${parentId}-${col}`;
      const ci = nodeToPlaceholderCluster.get(clusterKey) || 0;
      const phId = `ph-${parentId}-${col}-${ci}`;
      if (pos.has(phId)) {
        waypoints.push(pos.get(phId));
      }
    }

    if (waypoints.length === 0) {
      const xHop = betweenColsX(p.col, c.col);
      pts.push({ x: xHop, y: S.y });
      pts.push({ x: xHop, y: E.y });
    } else {
      let prevY = S.y;
      for (let i = 0; i < waypoints.length; i++) {
        const wp = waypoints[i];
        const xHop = betweenColsX(wp.col - 1, wp.col);
        pts.push({ x: xHop, y: prevY });
        pts.push({ x: xHop, y: wp.centerY });
        prevY = wp.centerY;
      }
      const lastWp = waypoints[waypoints.length - 1];
      const xHop = betweenColsX(lastWp.col, c.col);
      pts.push({ x: xHop, y: prevY });
      pts.push({ x: xHop, y: E.y });
    }

    pts.push(E);
    return pts;
  }

  function polylinePath(points) {
    return points.map((pt, i) => (i === 0 ? `M ${pt.x},${pt.y}` : `L ${pt.x},${pt.y}`)).join(" ");
  }

  function render(inputNodes) {
    const stage = document.getElementById("stage");
    const wires = document.getElementById("wires");

    // Clear old
    [...stage.querySelectorAll(".node, .cluster-box")].forEach(el => el.remove());
    [...wires.querySelectorAll("path.edge")].forEach(el => el.remove());

    const { pos, nodeToPlaceholderCluster, clusterMeta, expandedNodes } = computePositions(inputNodes);

    // Auto-size stage
    let maxX = 0, maxY = 0;
    pos.forEach(p => {
      if (p.isPlaceholder) return;
      if (p.isCluster) {
        maxX = Math.max(maxX, p.x + p.clusterW);
        maxY = Math.max(maxY, p.y + p.clusterH);
      } else {
        maxX = Math.max(maxX, p.x + cfg.boxW);
        maxY = Math.max(maxY, p.y + cfg.boxH);
      }
    });
    stage.style.width  = (maxX + cfg.marginX) + "px";
    stage.style.height = (maxY + cfg.marginY) + "px";

    // Render cluster bounding boxes
    for (const cm of clusterMeta) {
      const cp = pos.get(cm.id);
      if (!cp) continue;
      const el = document.createElement("div");
      el.className = "cluster-box";
      el.style.left = cp.x + "px";
      el.style.top = cp.y + "px";
      el.style.width = cp.clusterW + "px";
      el.style.height = cp.clusterH + "px";
      el.innerHTML = `<span class="cluster-label">${cm.label}</span>`;
      stage.appendChild(el);
    }

    // Render nodes (expanded, not placeholders, not cluster virtual entries)
    expandedNodes.forEach(n => {
      const p = pos.get(n.id);
      if (!p) return;
      const el = document.createElement("div");
      el.className = "node";
      el.style.width = cfg.boxW + "px";
      el.style.height = cfg.boxH + "px";
      el.style.left = p.x + "px";
      el.style.top = p.y + "px";
      el.textContent = n.label;
      stage.appendChild(el);
    });

    // Render edges
    // 1. Cluster-level parent edges: from cluster's parents to the cluster bounding box
    for (const cm of clusterMeta) {
      for (const pid of cm.parentIds) {
        const pts = routeEdge(pid, cm.id, pos, nodeToPlaceholderCluster);
        if (pts.length) {
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("class", "edge");
          path.setAttribute("marker-end", "url(#arrow)");
          path.setAttribute("d", polylinePath(pts));
          wires.appendChild(path);
        }
      }
    }

    // 2. Regular node edges (parent is a node or a cluster)
    expandedNodes.forEach(n => {
      const parentIds = getParentIds(n);
      for (const pid of parentIds) {
        const pts = routeEdge(pid, n.id, pos, nodeToPlaceholderCluster);
        if (pts.length) {
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("class", "edge");
          path.setAttribute("marker-end", "url(#arrow)");
          path.setAttribute("d", polylinePath(pts));
          wires.appendChild(path);
        }
      }
    });
  }

  // Buttons
  Object.keys(CASES).forEach(key => {
    const btn = document.getElementById(key);
    if (btn) btn.onclick = () => render(CASES[key]);
  });

  // Initial
  render(CASES.case11);
</script>

</body>
</html>
